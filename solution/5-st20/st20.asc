
== Stage 5 : ST20

=== Découverte

L'archive obtenue suite à la résolution de l'étape précédente contient deux fichiers, `input.bin` et
`schematic.pdf`.

D'après le résultat de la commande `file`, le fichier `input.bin` ne correspond
pas à un format connu. Cependant, il contient quelques chaînes de caractères
intéressantes, comme présenté ci-dessous :

[source, console]
----
$ file input.bin
input.bin: data
$ strings input.bin
$ P#
$z$y
Boot ok
Code Ok
Decrypt
$ P#
[...]
a       qC$
 e         |
KEY:
congratulations.tar.bz2
[...]
----

Le fichier `schematic.pdf` correspond à l'image ci-dessous :

image::images/rk_schematic.svg[align='center', title='schematic.pdf']

Plusieurs informations intéressantes sont sur ce schéma :

* on y découvre la notion de http://en.wikipedia.org/wiki/Transputer["`transputer`"]
qui est une architecture matérielle particulière conçue pour effectuer des calculs en parallèle ;
* le vecteur de test fourni permet de déduire qu'il s'agit d'une implémentation d'un
algorithme de déchiffrement ;
* enfin, toujours au niveau de ce même vecteur de test, la chaîne déchiffrée mentionne une architecture
 dite "`ST20`".

La section http://en.wikipedia.org/wiki/Transputer#Design[Design] de la page Wikipedia sur les
transputers explique les grands principes de cette architecture matérielle. En particulier,
un transputer est capable de communiquer avec d'autres transputers à l'aide d'un lien série. De plus,
un transputer peut démarrer de façon classique à l'aide d'une ROM ou de façon plus originale
en utilisant un lien série. Le schéma fourni laisse penser que le transputer 0 démarre
de cette façon, en lisant les données du fichier `input.bin` avec un lien série.

La http://pdf.datasheetcatalog.com/datasheet/stmicroelectronics/4942.pdf[documentation] disponible
sur le processeur ST20 détaille ce mode de démarrage :

"When booting from a link, the ST20-GP1 will wait for the first bootstrap message to arrive on the
link. The first byte received down the link is the control byte. If the control byte is greater than 1 (i.e.
2 to 255), it is taken as the length in bytes of the boot code to be loaded down the link. The bytes
following the control byte are then placed in internal memory starting at location MemStart.
Following reception of the last byte the ST20-GP1 will start executing code at MemStart. The
memory space immediately above the loaded code is used as work space. A byte arriving on the
bootstrapping link after the last bootstrap byte, is retained and no acknowledge is sent until a
process inputs from the link."
-- ST20-GP1 datasheet

Pour comprendre la routine de déchiffrement implémentée au sein du fichier `input.bin`,
il va être nécessaire de désassembler les données correspondant au programme puis
de les analyser pour retrouver l'algorithme. Fort heureusement, un désassembleur
pour le processeur ST20 est disponible sur Internet : http://digifusion.jeamland.org/st20dis[st20dis].

De plus, l'identification sur Internet d'un
http://pdf.datasheetcatalog.com/datasheet/SGSThomsonMicroelectronics/mXruvtu.pdf[manuel] sur
le jeu d'instruction du processeur aide à interpréter la sortie du désassembleur.

=== Présentation de l'architecture

WARNING: à faire (si possible)

* architecture little-endian
* 3 registres en cascade
* mot = 4 octets

=== Rétro-conception

Pour commencer, le premier réflexe est alors de lancer `st20dis` sur le fichier `input.bin` en commençant
à désassembler à l'octet 0 :

[source, console]
----
$ st20dis-linux -A input.bin
; New subroutine 0+1; References: 0, Local Vars: 0
00000000: f8                    sub_0:        prod             ; product - A = A * B (no overflow check)

; New subroutine 1+d; References: 0, Local Vars: 76
00000001: 64 b4                 sub_1:        ajw #-4c         ; adjust workspace - Move workspace pointer
00000003: 40                                  ldc #0           ; load constant - A = n, B=A, C=B
00000004: d1                                  stl #1 [var_1]   ; store local - workspace[n] = A, A=B, B=C
00000005: 40                                  ldc #0           ; load constant - A = n, B=A, C=B
00000006: d3                                  stl #3 [var_3]   ; store local - workspace[n] = A, A=B, B=C
00000007: 24 f2                               mint             ; minimum integer - A = MostNeg
00000009: 24 20 50                            ldnlp #400       ; load non-local pointer - A = &A[n]
0000000c: 23 fc                               gajw             ; general adjust workspace - Wptr <=> A

; New subroutine e+f8; References: 0, Local Vars: 76
0000000e: 64 b4                 sub_e:        ajw #-4c         ; adjust workspace - Move workspace pointer
00000010: 2c 49                               ldc #c9          ; load constant - A = n, B=A, C=B
00000012: 21 fb                               ldpi [str_dd]    ; Load pointer to instruction - A = next instruction + A
00000014: 24 f2                               mint             ; minimum integer - A = MostNeg
[...]
----

Le désassembleur a l'air de fonctionner correctement et la sortie semble cohérente.
Cependant, la toute première instruction semble étrange. Le registre `A`
est mis à jour avec le résultat de la multiplication entre les registres `A`
et `B` sachant que, d'après la documentation, tous les registres sont dans un
état indéfini. En réalité, le premier octet du fichier (`0xf8`) correspond
à la valeur "`control byte`" qui spécifie, lors d'un démarrage via un lien série,
la quantité de données qui sera placée dans la mémoire du processeur pour être
executée.

Le code du démarrage du premier transputer est alors extrait avec les commandes
 ci-dessous :

[source, console]
----
$ dd if=input.bin count=1 bs=1 | xxd -
0000000: f8 <1>
$ dd if=input.bin bs=1 skip=1 count=$((0xf8)) of=t0.bin
----
<1> valeur du control byte

Le désassembleur `st20dis` est alors appelé sur le fichier `t0.bin` résultat
pour enfin obtenir le fichier <<_t0_asm>>.

==== Transputer 0

Le transputer 0 s'initialise avec les instructions ci-dessous qui ne servent
qu'à positionner le pointeur de pile :

[source, st20]
----
; New subroutine 0+d; References: 0, Local Vars: 76
00000000: 64 b4     sub_0:        ajw #-4c       ; réserve 76 variables locales
00000002: 40                      ldc #0
00000003: d1                      stl #1 [var_1] ; var_1 = 0
00000004: 40                      ldc #0
00000005: d3                      stl #3 [var_3] ; var_3 = 0
00000006: 24 f2                   mint           ; A = MostNeg (0x80000000)
00000008: 24 20 50                ldnlp #400     ; A = MostNeg @ 0x400
0000000b: 23 fc                   gajw           ; Wptr = MostNeg @ 0x400
----

L'exécution continue avec les instructions ci-dessous :

[source, st20]
----
; New subroutine d+eb; References: 0, Local Vars: 76
0000000d: 64 b4     sub_d:        ajw #-4c           ; réserve 76 variables locales (word)
0000000f: 2c 49                   ldc #c9
00000011: 21 fb                   ldpi [str_dc]
00000013: 24 f2                   mint
00000015: 48                      ldc #8
00000016: fb                      out               ; out(8, 0x80000000, "Boot ok")
00000017: 24 19     loc_17:       ldlp #49 [&var_73]
00000019: 24 f2                   mint              ; A = 0x80000000
0000001b: 54                      ldnlp #4          ; A = 0x80000000 + 4 * 4 = 0x80000010
0000001c: 4c                      ldc #c
0000001d: f7                      in                ; in(12, 0x80000010, &var_73)
0000001e: 24 79                   ldl #49 [var_73]
00000020: 21 a5                   cj loc_37         ; saute à loc_37 si var_73 == 0
00000022: 2c 4d                   ldc #cd
00000024: 21 fb                   ldpi [loc_f3]
00000026: 24 f2                   mint
00000028: 54                      ldnlp #4
00000029: 24 79                   ldl #49 [var_73]
0000002b: f7                      in                ; in(var_73, 0x80000010, loc_f3)
0000002c: 2c 43                   ldc #c3
0000002e: 21 fb                   ldpi [loc_f3]
00000030: 24 7a                   ldl #4a [var_74]
00000032: 24 79                   ldl #49 [var_73]
00000034: fb                      out               ; out(var_73, var_74, loc_f3)
00000035: 61 00                   j loc_17
----

Ce code fait appel à deux instructions d'entrée/sortie `in` et `out` qui ont
pour paramètres :

|===
| Instruction | Arg0 | Arg1 | Arg2

| `in`
| Longueur
| Pointeur vers un channel
| Adresse destination

| `out`
| Longueur
| Pointeur vers un channel
| Adresse source
|===

On peut alors résumer ce code ainsi :

* envoi de `"Boot ok"` sur le channel `0x80000000` ;
* lecture de 12 octets (3 mots) du channel `0x80000010` vers l'adresse `&var_73` (les variables
`var_73`, `var_74` et `var_75` sont mises à jour) ;
* si `var_73 == 0`, sortie de la boucle ;
* sinon lecture de `var_73` octets depuis le channel `0x80000010` vers l'adresse `loc_f3` ;
* écriture de `var_73` octets depuis l'adresse `loc_f3` vers le channel référencé
par `var_74`.

La documentation précise le rôle des channels `0x80000000` et `0x80000010` :

image::images/rk_st20_memmap.png[align='center']

Les channels `0x80000000` et `0x80000010` sont donc respectivement
la sortie et l'entrée du lien 0, qui n'est autre que le lien de démarrage qui permet
de lire le contenu du fichier `input.bin`.

NOTE: Dans le reste de ce document, un channel sera désigné par son index relatif
à `0x80000000`. Par exemple, le channel 4 correspond à l'adresse `0x80000010`.

Pour comprendre la nature des données stockées à l'adresse `&var_73`, on peut alors
simuler une lecture de 3 mots sur le channel 4 avec la commande `dd` :
[source, console]
----
$ dd if=input.bin bs=1 skip=$((1+0xf8)) count=12 | xxd -
0000000: 7100 0000 0400 0080 0000 0000
----

Le résultat de la lecture (instruction `in` à l'adresse `0x1d`) est donc :

* `var_73` : `0x71` ;
* `var_74` : `0x80000004` (channel 1) ;
* `var_75` : `0`.

Par la suite, `0x71` octets vont être lus sur le channel 4 puis envoyés sur le channel
1. L'opération peut alors être répétée plusieurs fois, jusqu'à obtenir une longueur
(`var_73`) égale à 0 :

[source, console]
----
$ dd if=input.bin bs=1 skip=$((1+0xf8+12+0x71)) count=12 | xxd -
0000000: 7100 0000 0800 0080 0000 0000
$ dd if=input.bin bs=1 skip=$((1+0xf8+12+0x71+12+0x71)) count=12 | xxd -
0000000: 7100 0000 0c00 0080 0000 0000
[...]
----

Ces opérations peuvent être automatisées par le script Ruby ci-dessous :

[source, ruby]
.split.rb
----
include::../../stage-5/split.rb[]
----

On obtient alors le résultat suivant :

[source, console]
----
$ ./split.rb input.bin
[+] control byte: 0xf8
[+] code written to input_code.bin
[+] 0x71 bytes => channel 1
[+] 0x71 bytes => channel 2
[+] 0x71 bytes => channel 3
[+] 0x31 bytes => channel 1
[+] 0x31 bytes => channel 1
[+] 0x31 bytes => channel 1
[+] 0x31 bytes => channel 2
[+] 0x31 bytes => channel 2
[+] 0x31 bytes => channel 2
[+] 0x31 bytes => channel 3
[+] 0x31 bytes => channel 3
[+] 0x31 bytes => channel 3
[+] 0x5c bytes => channel 1
[+] 0x5c bytes => channel 1
[+] 0x98 bytes => channel 1
[+] 0x70 bytes => channel 2
[+] 0xa8 bytes => channel 2
[+] 0x60 bytes => channel 2
[+] 0xa4 bytes => channel 3
[+] 0x7c bytes => channel 3
[+] 0x90 bytes => channel 3
[+] len: 0x00, channel: 0x00, var_75: 0x00
[+] wrote 0x254 bytes to input_channel_1.bin
[+] wrote 0x27c bytes to input_channel_2.bin
[+] wrote 0x2b4 bytes to input_channel_3.bin
[+] wrote 0x3d316 bytes to input_remaining.bin
----

Les données enregistrées dans `input_channel_1.bin`, `input_channel_2.bin` et
`input_channel_3.bin` seront analysées dans la suite de ce document :
d'après le schéma fourni, on peut supposer qu'il s'agit des données envoyées
respectivement aux transputers 1, 2 et 3.

On s'intéresse à ce stade aux données contenues dans le fichier `input_remaining.bin`,
c'est-à-dire les données présentes sur le lien 0 à la sortie de la boucle :

[source, console]
----
$ hexdump -C input_remaining.bin|head -n 4
00000000  4b 45 59 3a ff ff ff ff  ff ff ff ff ff ff ff ff  |KEY:............|
00000010  17 63 6f 6e 67 72 61 74  75 6c 61 74 69 6f 6e 73  |.congratulations|
00000020  2e 74 61 72 2e 62 7a 32  fe f3 50 dc 81 bc 97 27  |.tar.bz2..P....'|
00000030  89 ac 72 28 cb 50 a4 09  d3 18 17 fc c3 9a 61 a0  |..r(.P........a.|
[...]
----

Plusieurs valeurs intéressantes peuvent être distinguées :

* la chaîne de caractères `KEY:` ;
* une série de 12 octets valant `0xff` ;
* la valeur `0x17 = 23` sur un octet ;
* la chaîne de caractères `congratulations.tar.bz2` ;
* enfin des données semblant aléatoires, jusqu'à la fin du fichier.

On peut remarquer que la longueur de la chaîne `congratulations.tar.bz2` veut 23 octets.

L'analyse du code assembleur se poursuit alors à l'adresse `loc_37`, après la sortie de la boucle :

[source, st20]
----
00000037: 24 19     loc_37:       ldlp #49 [&var_73]
00000039: 24 f2                   mint
0000003b: 51                      ldnlp #1
0000003c: 4c                      ldc #c
0000003d: fb                      out               ; out(12, MostNeg @ 1, &var_73)
0000003e: 24 19                   ldlp #49 [&var_73]
00000040: 24 f2                   mint
00000042: 52                      ldnlp #2
00000043: 4c                      ldc #c
00000044: fb                      out                ; out(12, MostNeg @ 2, &var_73)
00000045: 24 19                   ldlp #49 [&var_73]
00000047: 24 f2                   mint
00000049: 53                      ldnlp #3
0000004a: 4c                      ldc #c
0000004b: fb                      out                ; out(12, MostNeg @ 3, &var_73)
0000004c: 29 44                   ldc #94
0000004e: 21 fb                   ldpi [str_e4]
00000050: 24 f2                   mint
00000052: 48                      ldc #8
00000053: fb                      out                ; out(8, MostNeg, "Code Ok")
----

Ces instructions se contentent d'écrire le contenu des variables `var_73`, `var_74` et `var_75`
sur les channels 1, 2, et 3. A la sortie de la première boucle, ces trois
variables valent 0 d'après la sortie du script `split.rb`. Les fichiers `input_channel_1.bin`, `input_channel_2.bin` et
`input_channel_3.bin` sont mis à jour en conséquence :

[source, console]
----
$ dd if=/dev/zero bs=1 count=12 of=input_channel_1.bin seek=$((0x254))
$ dd if=/dev/zero bs=1 count=12 of=input_channel_2.bin seek=$((0x27c))
$ dd if=/dev/zero bs=1 count=12 of=input_channel_3.bin seek=$((0x2b4))
----

Le message `Code Ok` est ensuite envoyé sur le channel 0 et l'exécution continue à l'adresse `loc_54` :

[source, st20]
----
00000054: 12                      ldlp #2 [&var_2]
00000055: 24 f2                   mint
00000057: 54                      ldnlp #4
00000058: 44                      ldc #4
00000059: f7                      in                 ; in(4, MostNeg @ 4, &var_2)
0000005a: 15                      ldlp #5 [&var_5]
0000005b: 24 f2                   mint
0000005d: 54                      ldnlp #4
0000005e: 4c                      ldc #c
0000005f: f7                      in                 ; in(12, MostNeg @ 4, &var_5)
00000060: 28 48                   ldc #88
00000062: 21 fb                   ldpi [str_ec]
00000064: 24 f2                   mint
00000066: 48                      ldc #8
00000067: fb                      out                ; out(8, MostNeg, "Decrypt")
00000068: 13                      ldlp #3 [&var_3]
00000069: 24 f2                   mint
0000006b: 54                      ldnlp #4
0000006c: 41                      ldc #1
0000006d: f7                      in                 ; in(1, MostNeg @ 4, &var_3)
0000006e: 19                      ldlp #9 [&var_9]
0000006f: 24 f2                   mint
00000071: 54                      ldnlp #4
00000072: 13                      ldlp #3 [&var_3]
00000073: f1                      lb
00000074: f7                      in                ; in(*var3, MostNeg @ 4, &var_9)
----

Il est intéressant de mettre en relation ces instructions avec les données du fichier
`remaining.bin` précédemment analysées :

* la lecture de 4 octets sur le channel 4 permet de stocker la chaîne `KEY:` dans `var_2` ;
* la lecture de 12 octets sur le channel 4 stocke les 12 octets valant `0xFF` dans `var_5`, `var_6` et `var_7` ;
* un octet est lu sur le channel 4, qui vaut 23 (longueur de `congratulations.tar.bz2`) ;
* 23 octets sont donc lus sur le channel, ce qui permet de stocker `congratulations.tar.bz2`
à l'adresse de `var_9`.

De plus, la chaîne `Decrypt` est envoyée sur le channel 0, ce qui laisse supposer que les instructions
à venir implémentent une routine de déchiffrement.

Le transputer 0 poursuit son exécution avec les instructions ci-dessous :

[source, st20]
----
00000075: 40                      ldc #0
00000076: d4                      stl #4 [var_4]    ; var_4 = 0
00000077: 11        loc_77:       ldlp #1 [&var_1]
00000078: 24 f2                   mint
0000007a: 54                      ldnlp #4
0000007b: 41                      ldc #1
0000007c: f7                      in                ; in(1, MostNeg @ 4, &var_1)
0000007d: 15                      ldlp #5 [&var_5]
0000007e: 24 f2                   mint
00000080: 51                      ldnlp #1
00000081: 4c                      ldc #c
00000082: fb                      out               ; out(12, MostNeg @ 1, &var_5)
00000083: 15                      ldlp #5 [&var_5]
00000084: 24 f2                   mint
00000086: 52                      ldnlp #2
00000087: 4c                      ldc #c
00000088: fb                      out               ; out(12, MostNeg @ 2, &var_5)
00000089: 15                      ldlp #5 [&var_5]
0000008a: 24 f2                   mint
0000008c: 53                      ldnlp #3
0000008d: 4c                      ldc #c
0000008e: fb                      out               ; out(12, MostNeg @ 3, &var_5)
0000008f: 10                      ldlp #0 [&var_0]
00000090: 81                      adc #1
00000091: 24 f2                   mint
00000093: 55                      ldnlp #5
00000094: 41                      ldc #1
00000095: f7                      in                ; in(1, MostNeg @ 5, &var_0 + 1)
00000096: 10                      ldlp #0 [&var_0]
00000097: 82                      adc #2
00000098: 24 f2                   mint
0000009a: 56                      ldnlp #6
0000009b: 41                      ldc #1
0000009c: f7                      in                ; in(1, MostNeg @ 6, &var_0 + 2)
0000009d: 10                      ldlp #0 [&var_0]
0000009e: 83                      adc #3
0000009f: 24 f2                   mint
000000a1: 57                      ldnlp #7
000000a2: 41                      ldc #1
000000a3: f7                      in                ; in(1, MostNeg @ 7, &var_0 + 3)
000000a4: 10                      ldlp #0 [&var_0]
000000a5: 81                      adc #1
000000a6: f1                      lb
000000a7: 10                      ldlp #0 [&var_0]
000000a8: 82                      adc #2
000000a9: f1                      lb
000000aa: 23 f3                   xor               ; A = var_0[2] ^ var_0[1]
000000ac: 10                      ldlp #0 [&var_0]
000000ad: 83                      adc #3
000000ae: f1                      lb
000000af: 23 f3                   xor               ; A = var_0[3] ^ ( var_0[2] ^ var_0[1] )
000000b1: 10                      ldlp #0 [&var_0]
000000b2: 81                      adc #1
000000b3: 23 fb                   sb                ; var_0[1] = var_0[3] ^ ( var_0[2] ^ var_0[1] )
000000b5: 11                      ldlp #1 [&var_1]
000000b6: f1                      lb                ; A = var_1
000000b7: 74                      ldl #4 [var_4]    ; A = var_4, B = var_1
000000b8: 15                      ldlp #5 [&var_5]  ; A = &var_5, B = var_4, C = var_1
000000b9: f2                      bsub              ; A = &var_5 + var_4, B = var_1
000000ba: f1                      lb                ; A = var_5[var_4], B = var_1
000000bb: 74                      ldl #4 [var_4]    ; A = var_4, B = var_5[var_4], C = var_1
000000bc: 2c f1                   ssub              ; A = var_4 + 2 * var_5[var_4], B = var_1
000000be: 23 f3                   xor               ; A = (var_4 + 2 * var_5[var_4]) ^ var_1
000000c0: 10                      ldlp #0 [&var_0]
000000c1: 23 fb                   sb                ; var_0[0] = (var_4 + 2 * var_5[var_4]) ^ var_1
000000c3: 10                      ldlp #0 [&var_0]
000000c4: 81                      adc #1
000000c5: f1                      lb                ; A = var_0[1]
000000c6: 74                      ldl #4 [var_4]
000000c7: 15                      ldlp #5 [&var_5]
000000c8: f2                      bsub              ; A = &var_5 + var_4, B = var_0[1]
000000c9: 23 fb                   sb                ; var_5[var_4] = var_0[1]
000000cb: 74                      ldl #4 [var_4]
000000cc: 81                      adc #1
000000cd: 25 fa                   dup               ; A = var_4 + 1, B = var_4 + 1
000000cf: d4                      stl #4 [var_4]    ; var_4 var_4 + 1, A = var_4 + 1
000000d0: cc                      eqc #c
000000d1: a3                      cj loc_d5         ; saute à loc_d5 si var_4 != 12
000000d2: 80                      adc #0
000000d3: 40                      ldc #0
000000d4: d4                      stl #4 [var_4]    ; var_4 = 0
000000d5: 10        loc_d5:       ldlp #0 [&var_0]
000000d6: 24 f2                   mint
000000d8: 41                      ldc #1
000000d9: fb                      out               ; out(1, MostNeg, &var_0)
000000da: 66 0b                   j loc_77          ; saute à loc_77
000000dc: **        str_dc:      .string "Boot ok"
000000e4: **        str_e4:      .string "Code Ok"
000000ec: **        str_ec:      .string "Decrypt"
000000f4: 24 bc                   ajw #4c
000000f6: 22 f0                   ret
----

Il s'agit de la boucle principale du transputer 0. La variable `var_4` est mise à 0 puis la boucle
effectue les opérations suivantes :

* `loc_7c` : lecture d'un octet depuis le channel 4, stockage dans `var_1` ;
* `loc_80` à `loc_8e` : envoi des 12 octets à l'adresse `&var_5` vers les channels 1, 2, 3 ;
* `loc_8f` à `loc_a3` : lecture d'un octet sur les channels 5, 6, et 7, respectivement stocké dans `var_0[1]`, `var_0[2]` et `var_0[3]` ;
* `loc_b3` : mise à jour de l'octet `var_0[1]` avec l'opération `var_0[3] ^ ( var_0[2] ^ var_0[1] )` ;
* `loc_c1` : mise à jour de l'octet `var_0[0]` avec l'opération `(var_4 + 2 * var_5[var_4]) ^ var_1` ;
* `loc_c9` : mise à jour de l'octet `var_5[var_4]` avec l'octet précédemment calculé `var_0[1]` ;
* `loc_cb` à `loc_d4` : incrément de 1 de la variable `var_4`, remise à 0 si `var_4 == 12` ;
* `loc_d5` à `loc_da`: envoi de l'octet `var_0[0]` sur le channel 0 et retour au début de la boucle.

Sachant qu'il s'agit très certainement d'une routine de déchiffrement, il est raisonnable de faire
les hypothèses suivantes sur le rôle de chaque variable :

* `var_4` est un compteur de boucle qui varie entre 0 et 11 ;
* `var_1` est un octet chiffré ;
* `var_5` contient la clé courante (12 fois `0xff` à l'entrée de la boucle),
celle-ci est envoyée aux transputers 1, 2 et 3 via leurs channels respectifs ;
* les transputers 1, 2 et 3 retournent chacun un octet sur les channels 5, 6 et 7 qui sont stockés dans
la variable temporaire `var_0` ;
* `var_0[1]` contient un octet qui sera utilisé pour mettre à jour la clé courante à la position `var_4` ;
* `var_0[0]` correspond au résultat du déchiffrement de l'octet stocké dans `var_1`.

Ces opérations peuvent être traduites en pseudo-code C de la façon suivante :

[source, c]
----
void transputer_0(void) {
    uint8_t c, p, t1, t2, t3, i;
    uint8_t key[12] = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
    i = 0;
    for (;;) {
       in(1, 4, &c);    // lecture de l'octet chiffré

       out(12, 1, key); // envoi de la clé au transputer 1
       out(12, 2, key); // envoi de la clé au transputer 2
       out(12, 3, key); // envoi de la clé au transputer 3

       in(1, 5, &t1);   // lecture d'un octet depuis le transputer 1
       in(1, 6, &t2);   // lecture d'un octet depuis le transputer 2
       in(1, 7, &t3);   // lecture d'un octet depuis le transputer 3

       p = ( i + 2 * key[i] ) ^ c; // déchiffrement de l'octet
       key[i] = t3 ^ (t2 ^ t1);    // mise à jour de la clé
       i++;
       i = (i % 12);

       out(1, 0, &p); // envoi de l'octet déchiffré
    }
}
----

Maintenant que le fonctionnement du transputer 0 est compris, il reste à analyser les transputers 1, 2 et 3
pour déterminer les traitements effectués sur la clé courante à chaque itération. Pour cela,
les données envoyées sur les channels 1, 2 et 3 avant le début de la boucle principale doivent
être examinées : il s'agit en pratique des fichiers `input_channel_1.bin`, `input_channel_2.bin` et
`input_channel_3.bin`.

==== Transputers 1, 2 et 3

Pour des raisons de clarté, les fichiers `input_channel_1.bin`, `input_channel_2.bin` et
`input_channel_3.bin` ont été renommés en `t1.bin`, `t2.bin` et `t3.bin`.

De façon similaire au premier transputer, ces trois transputers démarrent sur un lien série.
Pour le transputer 1, la valeur du "`control byte`" et le bloc de code sont extraits avec les commandes ci-dessous :

[source, console]
----
$ dd if=t1.bin count=1 bs=1 | xxd -
0000000: 70
$ dd if=t1.bin count=$((0x70)) bs=1 skip=1 of=t1_code.bin
----

Le résultat peut alors être désassemblé avec `st20dis` : 

[source, console]
----
$ st20dis-linux t1_code.bin > t1.asm
----

Le fichier résultant <<_t1_asm>> est disponible en annexe.

Comme vu précédemment, le transputeur 1 commence par positionner le pointeur de pile :

[source, st20]
----
; New subroutine 0+9; References: 0, Local Vars: 8
00000000: 60 b8     sub_0:        ajw #-8       ; réserve 8 variables locales
00000002: 24 f2                   mint          ; A = MostNeg
00000004: 24 20 50                ldnlp #400    ; A = MostNeg @ 0x400
00000007: 23 fc                   gajw          ; Wptr = MostNeg @ 0x400
----

Une première boucle est ensuite exécutée :

[source, st20]
----
; New subroutine 9+67; References: 0, Local Vars: 8
00000009: 60 b8     sub_9:        ajw #-8           ; réserve 8 variables locales
0000000b: 15        loc_b:        ldlp #5 [&var_5]
0000000c: 24 f2                   mint 
0000000e: 54                      ldnlp #4
0000000f: 4c                      ldc #c
00000010: f7                      in                ; in(12, MostNeg @ 4, &var_5)
00000011: 75                      ldl #5 [var_5]
00000012: 21 a2                   cj loc_26         ; saute à loc_26 si var_5 == 0
00000014: 25 44                   ldc #54       
00000016: 21 fb                   ldpi [loc_6c]
00000018: 24 f2                   mint 
0000001a: 54                      ldnlp #4
0000001b: 75                      ldl #5 [var_5]
0000001c: f7                      in                ; in(var_5, MostNeg @ 4, loc_6c)
0000001d: 24 4b                   ldc #4b
0000001f: 21 fb                   ldpi [loc_6c]
00000021: 76                      ldl #6 [var_6]
00000022: 75                      ldl #5 [var_5]
00000023: fb                      out               ; out(var_5, var_6, loc_6c)
00000024: 61 05                   j loc_b
----

Cette boucle est quasiment identique à la première boucle du transputer 0. On est alors
tenté d'utiliser le script `split.rb` développé précédemment pour extraire les données
envoyées sur chaque channel :

[source, console]
----
$ ./split.rb t1.bin
[+] control byte: 0x70
[+] code written to t1_code.bin
[+] 0x25 bytes => channel 1
[+] 0x25 bytes => channel 2
[+] 0x25 bytes => channel 3
[+] 0x50 bytes => channel 1
[+] 0x50 bytes => channel 2
[+] 0x8c bytes => channel 3
[+] len: 0x00, channel: 0x00, var_75: 0x00
[+] wrote 0x75 bytes to t1_channel_1.bin
[+] wrote 0x75 bytes to t1_channel_2.bin
[+] wrote 0xb1 bytes to t1_channel_3.bin
[+] wrote 0x00 bytes to t1_remaining.bin
$ ./split.rb t2.bin
[+] control byte: 0x70
[+] code written to t2_code.bin
[+] 0x25 bytes => channel 1
[+] 0x25 bytes => channel 2
[+] 0x25 bytes => channel 3
[+] 0x64 bytes => channel 1
[+] 0x9c bytes => channel 2
[+] 0x54 bytes => channel 3
[+] len: 0x00, channel: 0x00, var_75: 0x00
[+] wrote 0x89 bytes to t2_channel_1.bin
[+] wrote 0xc1 bytes to t2_channel_2.bin
[+] wrote 0x79 bytes to t2_channel_3.bin
[+] wrote 0x00 bytes to t2_remaining.bin
$ ./split.rb t3.bin
[+] control byte: 0x70
[+] code written to t3_code.bin
[+] 0x25 bytes => channel 1
[+] 0x25 bytes => channel 2
[+] 0x25 bytes => channel 3
[+] 0x98 bytes => channel 1
[+] 0x70 bytes => channel 2
[+] 0x84 bytes => channel 3
[+] len: 0x00, channel: 0x00, var_75: 0x00
[+] wrote 0xbd bytes to t3_channel_1.bin
[+] wrote 0x95 bytes to t3_channel_2.bin
[+] wrote 0xa9 bytes to t3_channel_3.bin
[+] wrote 0x00 bytes to t3_remaining.bin
----

Le script fonctionne correctement sur les trois transputers et pour chacun d'eux, les
données envoyées sur les channels 1, 2 et 3 sont extraites. On peut remarquer qu'après avoir
effectué cette première boucle, il n'y a plus de données en attente sur le lien série (les fichiers
`t1_remaining.bin`, `t2_remaining.bin` et `t3_remaining.bin` sont vides).
On remarque également que le "`control byte`" est identique pour les trois transputers. En réalité, le code
extrait est le même pour les trois, comme indiqué ci-dessous :

[source, console]
----
$ md5sum t*_code.bin
0cbeb2a7a4f269356aeec0fe6bfc9192  t1_code.bin
0cbeb2a7a4f269356aeec0fe6bfc9192  t2_code.bin
0cbeb2a7a4f269356aeec0fe6bfc9192  t3_code.bin
----

Il suffit donc d'analyser un seul transputer pour comprendre les trois.

L'analyse continue ensuite après la première boucle, à l'adresse `loc_26` :

[source, st20]
----
00000026: 11        loc_26:       ldlp #1 [&var_1]
00000027: 24 f2                   mint 
00000029: 54                      ldnlp #4
0000002a: 4c                      ldc #c
0000002b: f7                      in                 ; in(12, MostNeg @ 4, &var_1)
0000002c: 11                      ldlp #1 [&var_1]
0000002d: 24 f2                   mint 
0000002f: 51                      ldnlp #1
00000030: 4c                      ldc #c
00000031: fb                      out                ; out(12, MostNeg @ 1, &var_1)
00000032: 11                      ldlp #1 [&var_1]
00000033: 24 f2                   mint 
00000035: 52                      ldnlp #2
00000036: 4c                      ldc #c
00000037: fb                      out                ; out(12, MostNeg @ 2, &var_1)
00000038: 11                      ldlp #1 [&var_1]
00000039: 24 f2                   mint 
0000003b: 53                      ldnlp #3
0000003c: 4c                      ldc #c
0000003d: fb                      out                ; out(12, MostNeg @ 3, &var_1)
0000003e: 10                      ldlp #0 [&var_0]
0000003f: 81                      adc #1
00000040: 24 f2                   mint 
00000042: 55                      ldnlp #5
00000043: 41                      ldc #1
00000044: f7                      in                 ; in(1, MostNeg @ 5, &var_0 + 1)
00000045: 10                      ldlp #0 [&var_0]
00000046: 82                      adc #2
00000047: 24 f2                   mint 
00000049: 56                      ldnlp #6
0000004a: 41                      ldc #1
0000004b: f7                      in                 ; in(1, MostNeg @ 6, &var_0 + 2)
0000004c: 10                      ldlp #0 [&var_0] 
0000004d: 83                      adc #3
0000004e: 24 f2                   mint 
00000050: 57                      ldnlp #7
00000051: 41                      ldc #1
00000052: f7                      in                 ; in(1, MostNeg @ 7, &var_0 + 3)
00000053: 10                      ldlp #0 [&var_0]
00000054: 81                      adc #1
00000055: f1                      lb                 ; A = var_0[1]
00000056: 10                      ldlp #0 [&var_0]
00000057: 82                      adc #2
00000058: f1                      lb                 ; A = var_0[2], B = var_0[1]
00000059: 23 f3                   xor                ; A = var_0[2] ^ var_0[1]
0000005b: 10                      ldlp #0 [&var_0]
0000005c: 83                      adc #3
0000005d: f1                      lb                 ; A = var_0[3], B = var_0[2] ^ var_0[1]
0000005e: 23 f3                   xor                ; A = var_0[3] ^ (var_0[2] ^ var_0[1])
00000060: 25 fa                   dup                ; A = var_0[3] ^ (var_0[2] ^ var_0[1]), B = A
00000062: 10                      ldlp #0 [&var_0]   
00000063: 23 fb                   sb                 ; var_0[0] = var_0[3] ^ (var_0[2] ^ var_0[1])
00000065: 10                      ldlp #0 [&var_0]
00000066: 24 f2                   mint 
00000068: 41                      ldc #1
00000069: fb                      out                ; out(1, MostNeg, var_0[3] ^ (var_0[2] ^ var_0[1]))
0000006a: 64 0a                   j loc_26           ; saute à loc_26
0000006c: 00        loc_6c:       nop 
0000006d: b8                      ajw #8
0000006e: 22 f0                   ret
----

Ce code revient à effectuer les opérations suivantes :

* `loc_26` à `loc_2b` : lecture de 12 octets du channel 4 vers l'adresse de `var_1` ;
* `loc_2c` à `loc_3d` : envoi de 12 octets de l'adresse de `var_1` vers les channels 1, 2 et 3 ;
* `loc_3e` à `loc_52` : lecture d'un octet sur les channels 5, 6, et 7, respectivement stocké dans `var_0[1]`, `var_0[2]` et `var_0[3]` ;
* `loc_53` à `loc_63` : mise à jour de l'octet `var_0[0]` avec l'opération `var_0[3] ^ ( var_0[2] ^ var_0[1] )` ;
* `loc_65` à `loc_6a` : envoi de l'octet `var_0[0]` vers le channel 0 et saute à l'adresse `loc_26`.

Ces opérations peuvent être traduites en pseudo-code C de la façon suivante :

[source, c]
----
void transputer_1(void) {
    uint8_t res, t4, t5, t6;
    uint8_t key[12];

    for (;;) {
        in(12, 4, key); // lecture de la clé

        out(12, 1, key); // envoi de la clé au transputer 4
        out(12, 2, key); // envoi de la clé au transputer 5
        out(12, 3, key); // envoi de la clé au transputer 6

        in(1, 5, &t4); // lecture d'un octet depuis le transputer 4
        in(1, 6, &t5); // lecture d'un octet depuis le transputer 5
        in(1, 7, &t6); // lecture d'un octet depuis le transputer 6

        res = t6 ^ (t5 ^ t4);

        out(1, 0, &res); // envoi de res sur le channel 0
    }
}
----

Le fonctionnement des transputers 2 et 3 est identique. Pour terminer l'analyse,
il faut donc s'intéresser aux transputers 4 à 7.

==== Transputers 4 à 7

Le transputer 4 est initialisé avec les données envoyées par le transputer 1 sur le channel 1,
c'est-à-dire :

[source, console]
----
$ hexdump -C t1_channel_1.bin 
00000000  24 60 bd 24 f2 24 20 50  23 fc 60 bd 10 24 f2 54  |$`.$.$ P#.`..$.T|
00000010  4c f7 4b 21 fb 24 f2 54  70 f7 43 21 fb 72 f2 f6  |L.K!.$.Tp.C!.r..|
00000020  00 b3 22 f0 20 44 00 00  00 00 00 00 00 0c 00 00  |..". D..........|
00000030  00 73 72 74 f7 22 f0 73  72 74 fb 22 f0 60 bb 40  |.srt.".srt.".`.@|
00000040  d1 40 11 23 fb 4c d0 12  24 f2 54 76 61 93 40 d0  |.@.#.L..$.Tva.@.|
00000050  70 12 f2 f1 11 f1 f2 2f  4f 24 f6 11 23 fb 70 81  |p....../O$..#.p.|
00000060  d0 4c 70 f9 a2 61 09 41  d0 11 24 f2 76 63 98 20  |.Lp..a.A..$.vc. |
00000070  62 03 20 20 20                                    |b.   |
00000075
----

Le "`control byte`" valant `0x24, on peut alors extraire le code d'initialisation et le
désassembler :

[source, console]
----
$ dd if=t1_channel_1.bin of=t4_code.bin bs=1 skip=1 count=$((0x24))
$ dd if=t1_channel_1.bin of=t4_remaining.bin bs=1 skip=$((1+0x24))
$ st20dis-linux t4_code.bin > t4.asm
----

Le résultat du désassemblage est présenté ci-dessous :

[source, st20]
.t4.asm
----
; New subroutine 0+9; References: 0, Local Vars: 3
00000000: 60 bd     sub_0:        ajw #-3            ; réserve 3 variables
00000002: 24 f2                   mint 
00000004: 24 20 50                ldnlp #400         
00000007: 23 fc                   gajw               ; Wptr = MostNeg @ 0x400

; New subroutine 9+1b; References: 0, Local Vars: 3
00000009: 60 bd     sub_9:        ajw #-3            ; réserve 3 variables
0000000b: 10                      ldlp #0 [&var_0]
0000000c: 24 f2                   mint 
0000000e: 54                      ldnlp #4
0000000f: 4c                      ldc #c             
00000010: f7                      in                 ; in(12, MostNeg @ 4, &var_0)
00000011: 4b                      ldc #b
00000012: 21 fb                   ldpi [loc_1f]
00000014: 24 f2                   mint 
00000016: 54                      ldnlp #4
00000017: 70                      ldl #0 [var_0]
00000018: f7                      in                 ; in(var_0, MostNeg @ 4, loc_1f)
00000019: 43                      ldc #3
0000001a: 21 fb                   ldpi [loc_1f]
0000001c: 72                      ldl #2 [var_2]
0000001d: f2                      bsub               ; A = var_2 + loc_1f
0000001e: f6                      gcall              ; gcall(var_2 + loc_1f)
0000001f: 00        loc_1f:       nop 
00000020: b3                      ajw #3
00000021: 22 f0                   ret 
00000023: 20                      .db #20 ' '
----

[source, console]
----
$ dd if=t4_remaining.bin bs=1 count=12 | xxd -
0000000: 4400 0000 0000 0000 0c00 0000            D...........
----

Les trois variables sont alors initialisées de la façon suivante :

* `var_0` : `0x44` ;
* `var_1` : `0` ;
* `var_2` : `0xc`.

[source, console]
----
$ dd if=t4_remaining.bin bs=1 count=$((0x44)) skip=12 > t4_code_gcall.bin
$ hexdump -C t4_code_gcall.bin 
00000000  73 72 74 f7 22 f0 73 72  74 fb 22 f0 60 bb 40 d1  |srt.".srt.".`.@.|
00000010  40 11 23 fb 4c d0 12 24  f2 54 76 61 93 40 d0 70  |@.#.L..$.Tva.@.p|
00000020  12 f2 f1 11 f1 f2 2f 4f  24 f6 11 23 fb 70 81 d0  |....../O$..#.p..|
00000030  4c 70 f9 a2 61 09 41 d0  11 24 f2 76 63 98 20 62  |Lp..a.A..$.vc. b|
00000040  03 20 20 20                                       |.   |
00000044
$ st20dis-linux t4_code_gcall.bin > t4_code_gcall.asm
----

[source, st20]
.t4_code_gcall.asm
----
; New subroutine 0+6; References: 1, Local Vars: 0
;       Called/referenced from 1b
00000000: 73     sub_0:        ldl #3 [arg_3]
00000001: 72                   ldl #2 [arg_2]
00000002: 74                   ldl #4 [arg_4]
00000003: f7                   in 
00000004: 22 f0                ret 

; New subroutine 6+6; References: 1, Local Vars: 0
;       Called/referenced from 3c
00000006: 73     sub_6:        ldl #3 [arg_3]
00000007: 72                   ldl #2 [arg_2]
00000008: 74                   ldl #4 [arg_4]
00000009: fb                   out 
0000000a: 22 f0                ret 

; New subroutine c+38; References: 0, Local Vars: 5
0000000c: 60 bb  sub_c:        ajw #-5           ; point d'entrée
0000000e: 40                   ldc #0
0000000f: d1                   stl #1 [var_1]
00000010: 40                   ldc #0
00000011: 11                   ldlp #1 [&var_1]
00000012: 23 fb                sb 
00000014: 4c     loc_14:       ldc #c
00000015: d0                   stl #0 [var_0]
00000016: 12                   ldlp #2 [&var_2]
00000017: 24 f2                mint 
00000019: 54                   ldnlp #4
0000001a: 76                   ldl #6 [arg_1]
0000001b: 61 93                call sub_0
0000001d: 40                   ldc #0
0000001e: d0                   stl #0 [var_0]
0000001f: 70     loc_1f:       ldl #0 [var_0]
00000020: 12                   ldlp #2 [&var_2]
00000021: f2                   bsub 
00000022: f1                   lb 
00000023: 11                   ldlp #1 [&var_1]
00000024: f1                   lb 
00000025: f2                   bsub 
00000026: 2f 4f                ldc #ff
00000028: 24 f6                and 
0000002a: 11                   ldlp #1 [&var_1]
0000002b: 23 fb                sb 
0000002d: 70                   ldl #0 [var_0]
0000002e: 81                   adc #1
0000002f: d0                   stl #0 [var_0]
00000030: 4c                   ldc #c
00000031: 70                   ldl #0 [var_0]
00000032: f9                   gt 
00000033: a2                   cj loc_36
00000034: 61 09                j loc_1f
00000036: 41     loc_36:       ldc #1
00000037: d0                   stl #0 [var_0]
00000038: 11                   ldlp #1 [&var_1]
00000039: 24 f2                mint 
0000003b: 76                   ldl #6 [arg_1]
0000003c: 63 98                call sub_6
0000003e: 20                   .db #20 ' '
0000003f: 62 03                j loc_14
00000041: 20                   .db #20 ' '
00000042: 20                   .db #20 ' '
00000043: 20                   .db #20 ' '
----

=== Détermination de la clé

Maintenant que l'algorithme de la routine déchiffrement est globalement compris,
il reste à déterminer la clé valide permettant de déchiffrer les données
embarquées dans le fichier `input.bin`. La démarche initiale est la suivante :

* recoder une implémentation, si possible rapide, de la routine de déchiffrement ;
* vérifier que l'implémentation passe le vecteur de test ;
* déterminer une liste de clés candidates et, pour chacune, :
** effectuer un déchiffrement,
** calculer l'empreinte SHA256 des données obtenues et comparer le résultat
avec l'empreinte `decrypted` présente sur le schéma `schematic.pdf`.

Si les deux empreintes sont identiques, alors la clé candidate courante est celle
recherchée.

Cette approche se heurte cependant à plusieurs difficultés :

* sachant que la longueur de la clé est de 12 octets, soit 96 bits,
l'espace de clés à tester est gigantesque (stem:[2^96] clés différentes) ;
* l'algorithme de déchiffrement n'est pas particulièrement efficace car il agit
octet par octet sur les données chiffrées : le test d'une clé est en conséquence
assez long.

Pour poursuivre, ces deux difficultés doivent être résolues. Au niveau du nombre de clés à tester,
il est possible de fortement réduire leur nombre. En effet, si on reprend l'algorithme
de déchiffrement, on peut se rendre compte que les 12 premiers octets déchiffrés
sont directement corrélés avec la clé par la formule suivante :

[stem]
++++
p_i = c_i \oplus ( (2 * k_i + i) % 256 )
++++

où stem:[p_i] est l'octet déchiffré, stem:[c_i] l'octet chiffré et stem:[k_i] l'octet
de clé à la position stem:[i], pour stem:[i in [0, 11]]. L'opération modulo 256
est nécessaire car le résultat est stocké dans octet (soit un entier de 8 bits).

La formule précédente revient à dire qu'il existe un entier stem:[n] tel que :

[stem]
++++
256 * n + c_i \oplus p_i = 2 * k_i + i
++++

Un octet de clé est donc corrélé avec les octets de clair et chiffré correspondants
de la façon suivante :

[stem]
++++
k_i = (256 * n + c_i \oplus p_i - i) / 2 = 128 * n + (c_i \oplus p_i - i) / 2
++++

Par conséquent, en identifiant un clair connu sur le début du fichier, on pourra
alors réduire grandement l'espace des clés à tester. On peut alors faire l'hypothèse,
 à cause de la présence de la chaîne `congratulations.tar.bz2` dans le fichier `input.bin`,
que les données déchiffrées correspondant à une archive au standard bzip2.

La page Wikipedia sur bzip2 décrit le http://en.wikipedia.org/wiki/Bzip2#File_format[format] d'un
fichier bzip2. On identifie alors certaines valeurs constantes au début du fichier :

[source]
----
.magic:16                       = 'BZ' signature/magic number
.version:8                      = 'h' for Bzip2 ('H'uffman coding), '0' for Bzip1 (deprecated)
.hundred_k_blocksize:8          = '1'..'9' block-size 100 kB-900 kB (uncompressed)

.compressed_magic:48            = 0x314159265359 (BCD (pi))
.crc:32                         = checksum for this block
----

Il s'agit donc de :

* `BZh` pour les trois premiers octets ;
* une valeur comprise entre 1 et 9 pour le quatrième octet ;
* enfin la valeur de Pi pour les 6 octets suivants.

Les 10 premiers octets sont donc prévisibles et permettent de limiter les clés
candidates. Pour cela, un script Ruby a été développé qui détermine, pour les 10
premiers octets, les valeurs possibles d'un octet de clé en fonction de l'octet
de clair connu et de l'octet chiffré correspondants.

[source, ruby]
.find-key.rb
----
include::../../stage-5/find-key.rb[]
----

Le script génère un fichier `.h` contenant 5120 clés qui peut alors être inclus dans un programme en
C pour effectuer l'attaque par force brute.

[source, console]
----
$ ./find-key.rb
#define KEYS_COUNT 5120

char keys[KEYS_COUNT][12] = {
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0x7d, 0x69, 0x76, 0x00, 0x00 },
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0x7d, 0x69, 0xf6, 0x00, 0x00 },
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0x7d, 0xe9, 0x76, 0x00, 0x00 },
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0x7d, 0xe9, 0xf6, 0x00, 0x00 },
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0xfd, 0x69, 0x76, 0x00, 0x00 },
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0xfd, 0x69, 0xf6, 0x00, 0x00 },
    { 0x5e, 0x54, 0x1b, 0x75, 0x56, 0x7c, 0x64, 0xfd, 0xe9, 0x76, 0x00, 0x00 },
[...]
----

Les deux derniers octets doivent être déterminés par force brute, ce qui revient
à un espace de clés correspondant à stem:[5120 * 2^8 * 2^8 = 5120 * 2^16] possibilités.

La seconde difficulté réside dans la lenteur de l'algorithme qui limite
les possibilités d'attaque par force brute. Pour contourner cette difficulté,
l'idéal serait de pouvoir éliminer les mauvaises clés candidates sans avoir
à déchiffrer l'intégralité des données. S'il est possible de déterminer un clair connu
dans le début du fichier déchiffré (autre que les 10 premiers octets), alors une
vérification sur le début des données déchiffrées permettrait de ne retenir que les
bons candidats. Si une clé candidate passe ce premier filtre, alors un déchiffrement
complet est ensuite réalisé pour comparer les empreintes SHA256.

Un fichier au format bzip2, de taille comparable à celui recherché, est alors
généré pour tenter d'identifier un clair connu :

[source, console]
----
$ dd if=/dev/urandom of=test.bin bs=256K count=1
1+0 records in
1+0 records out
262144 bytes (262 kB) copied, 0.0222051 s, 11.8 MB/s
$ bzip2 test.bin
$ hexdump -C test.bin.bz2
00000000  42 5a 68 39 31 41 59 26  53 59 48 b3 90 17 00 32  |BZh91AY&SYH....2|
00000010  78 ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |x...............|
00000020  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  |................|
[...]
----

On remarque que le début du fichier contient de nombreuses occurences de la valeur `0xff`. L'heuristique
retenue consiste alors à tester la présence des octets `ff ff ff ff` dans les
32 premiers octets déchiffrés.

Une version simpliée de l'attaque par force brute est présentée ci-dessous :

[source, c]
----
const char *plain_sha256 = "9128135129d2be652809f5a1d337211affad91ed5827474bf9bd7e285ecef321";

void bf(const char *cipher_data, int size) {
        char *key;
        char *plain_data = NULL;
        char sha256[65];
        int i, j, k, l;

        plain_data = malloc(size);

        for (i = 0; i < KEYS_COUNT; i++) {
                key = keys[i];

                for (j = 0; j < 256; j++) {
                        key[10] = j;

                        for (k = 0; k < 256; k++) {
                                key[11] = k;

                                decipher(key, cipher_data, plain_data, 32);
                                if (!memmem(plain_data, 32, "\xFF\xFF\xFF\xFF", 4))
                                        continue;

                                decipher(key, cipher_data, plain_data, size);
                                sha256sum(plain_data, size, sha256);

                                if (!strncmp(sha256, plain_sha256, 64)) {
                                        fprintf(stderr, "[!] key = ");
                                        for (l = 0; l < 12; l++)
                                                fprintf(stderr, "%2.2x", key[l] & 0xff);

                                        goto finish;
                                }
                        }
                }
        }

finish:
        if (plain_data)
                free(plain_data);
}
----

Une version améliorée, disponible en annexe (<<_recode_c>>), utilise OpenMP pour
paralléliser les calculs et permet de retrouver la clé valide en l'espace d'une minute :

[source, console]
----
$ make clean && make recode
rm recode keys.h
./find-key.rb > keys.h
gcc -O3 -march=native -fomit-frame-pointer -fopenmp -funroll-loops -Wall -o recode recode.c -lcrypto
$ dd if=input.bin bs=1 skip=$((0x9ad)) count=$((0x3dc9a-0x9ad+1)) of=encrypted.bin
250606+0 records in
250606+0 records out
250606 bytes (251 kB) copied, 0.333976 s, 750 kB/s
$ sha256sum encrypted.bin
a5790b4427bc13e4f4e9f524c684809ce96cd2f724e29d94dc999ec25e166a81  encrypted.bin
$ ./recode encrypted.bin
[+] self-test passed
[+] starting 4 threads
[+] testing 5120 keys
[!] key = 5ed49b7156fce47de976dac5
[+] result saved in congratulations.tar.bz2
----

La clé a finalement été identifée (`5ed49b7156fce47de976dac5`) et le résultat est sauvegardé dans le fichier
`congratulations.tar.bz2`.
